#!/bin/bash
#
# Example:
#   ./perform_benchmarks.sh io 10000
#
set -euo pipefail

JOB_TYPE=$1 # io | cpu
JOBS=$2
THREADS=5
QUEUES=4
RUNNER="que"
CONCURRENCY_STEPS=(1 2 4 8)   # used for scalability loops

# Use the script's directory to source the other scripts
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

. "$SCRIPT_DIR/batch_spinner.sh"
. "$SCRIPT_DIR/batch_clean.sh"
. "$SCRIPT_DIR/batch_enqueue.sh"
. "$SCRIPT_DIR/batch_duration.sh"

RESULTS_CSV="results_${RUNNER}_$(date +%Y%m%d_%H%M%S).csv"
echo "workers,threads,avg_cpu_s,avg_rss_mb" > "$RESULTS_CSV"

echo "**********************************"
echo " RUNNER:      $RUNNER"
echo " JOB TYPE:    $JOB_TYPE"
echo " ACTUAL LOAD: $JOBS jobs"
echo " QUEUES     : $QUEUES"
echo "**********************************"

for WORKERS in "${CONCURRENCY_STEPS[@]}"; do
  echo
  echo " $WORKERS WORKER(S) x $THREADS THREADS"
  echo "========================================"

  show_spinner_clean_batch

  BATCH_ID=$(uuidgen)
  WORKER_BOOT_MS=$(date +%s%3N)

  for ((i=1;i<=WORKERS;i++)); do
    bundle exec que --worker-count "$THREADS" \
      -q queue_0 -q queue_1 -q queue_2 -q queue_3 -q queue_4 -q queue_5 -q queue_6 -q queue_7 \
      --poll-interval 0.1 > /dev/null 2>&1 &
    WPIDS[$i]=$!
  done

  # 2. Start resource monitor ------------------------------------------------
  RES_LOG="/tmp/resources_${BATCH_ID}.csv"
  "$SCRIPT_DIR/benchmarks/monitor_resources.sh" "$RES_LOG" "${WPIDS[@]}" &
  MONITOR_PID=$!

  # 3. Enqueue jobs ----------------------------------------------------------
  show_spinner_enqueue_jobs "$JOB_TYPE" "$QUEUES" "$JOBS"
  show_spinner_until_jobs_complete "$JOBS"

  # 6. Stop monitor & workers -----------------------------------------------
  kill "$MONITOR_PID" 2>/dev/null || true
  wait "$MONITOR_PID" 2>/dev/null || true
  kill "${WPIDS[@]}"   2>/dev/null || true
  wait "${WPIDS[@]}" 2>/dev/null || true

  # 5. Compute metrics -------------------------------------------------------
  show_batch_duration
  # Average CPU-seconds & RSS (MB) from resource log
  read -r AVG_CPU AVG_RSS <<<"$(awk -F, 'NR>1 {cpu+=$3; rss+=$2; n++} END {printf "%.2f %.2f", cpu/n, rss/n/1024}' "$RES_LOG")"

  # 7. Persist results -------------------------------------------------------
  printf '%s,%s,%s,%s,%s\n' \
     "$WORKERS" "$THREADS" "$AVG_CPU" "$AVG_RSS" \
     >> "$RESULTS_CSV"
done

echo "✅ Benchmark finished → $RESULTS_CSV"
